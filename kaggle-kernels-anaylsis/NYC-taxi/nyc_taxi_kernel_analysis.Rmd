---
title: "FIAP-04IA | Inteligência artificial com R"
author: "Raphael Prates"
date: "1 de novembro de 2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
# 1. Kaggle Kernel Analysis: NYC Taxi EDA
```{r, echo=FALSE,out.width='100%', fig.align='center'}
knitr::include_graphics('images/New-York-Taxi.jpg')
```
  
__Kernel name:__ "NYC Taxi EDA - Update: The fast & the curious"  
__Link:__ https://www.kaggle.com/headsortails/nyc-taxi-eda-update-the-fast-the-curious

## 1.1 Introduction
In this project we are going to explore the kernel above showing why the author choose the functions used, comparing to others alternatives and we are going to emphasize the interesting points of the kernel.
  
  
## 1.2 Load data
  
### Original code
```{r load_data_original, echo=TRUE, message=FALSE, warning=FALSE}
library("data.table")
library("tibble")

train <- as.tibble(fread('train.csv'))
```

### Comparison with others alternatives
In R, __read.csv__ is part of the regular functions and is used for load data.frame from a _csv_ file. But when we're dealing with a huge data.frame this function can take a long time to run. 
```{r l, echo=TRUE, message=FALSE, warning=FALSE}
print(paste("In this case the dataset is quite huge:",dim(train)[1], "rows and",
            dim(train)[2], "columns."))
```
So in this part the author used a function called __fread__ that performs much faster than _read.csv_ (check the time of each function using profvis!!).  
After that other function should be compared: __load__.
This function is used to load variables that have been stored in a _.RData_ file and runs very fast comparing with _read.csv_ and _fread_.  
When is a good ideia to use _load_?
When it's possible to use a background process to update the data.frame and save it in _.RData_ file.  
Let's take a look at the three possibilities:
```{r load_data_comparison, echo=TRUE, message=FALSE, warning=FALSE}
library("profvis")
library("data.table")
library("tibble")
library("readr")

profvis({
  # fread
  train <- fread("train.csv")
  test <- fread("test.csv")
  
  # read.csv
  train_readcsv <- read.csv("train.csv")
  
  # read_csv -> from "readr" package
  train_read_csv <- read_csv("train.csv")
  
  # as.tibble
  train <- as.tibble(train)
  test <- as.tibble(test)
  
  # loading RData
  save(train_readcsv, file = "train_data.RData")
  rm(train_readcsv)
  load(file = "train_data.RData")
})
```
  
### __Tibbles vs data frames__
All the information bellow was "greped" from https://cran.r-project.org/web/packages/tibble/vignettes/tibble.html  
__Tibbles__  
"Tibbles are a modern take on data frames. They keep the features that have stood the test of time, and drop the features that used to be convenient but are now frustrating (i.e. converting character vectors to factors)."  
  
Major points:  

* It never changes an input's type (i.e., no more stringsAsFactors = FALSE!);
* It never adjusts the names of variables (i.e names with spaces will keep the whitespace. Data.frame   replaces whitespace for '.');
* When you print a tibble, it only shows the first ten rows and all the columns that fit on one screen;
* Tibbles are quite strict about subsetting. __[ ]__ always returns another tibble. Contrast this with a data frame: sometimes __[ ]__ returns a data frame and sometimes it just returns a vector.
  
  
## 1.3 File structure and content  
```{r, echo=FALSE,out.width='25%', fig.align='center'}
knitr::include_graphics('images/sheldon.gif')
```
A brief overview of our data can summaries the descriptive statistics values of the dataset and detect abnormal items or outliers.

__For the summaries__
```{r echo=TRUE, message=FALSE, warning=FALSE}
summary(train)
summary(test)
```
__Data overview__
```{r echo=TRUE, message=FALSE, warning=FALSE}
library("dplyr")
glimpse(train)
glimpse(test)
```
### Comparison with others alternatives
Another popular way to make a data overview is using _str_. It is very similar to _glimpse_ but _str_ shows less data. 
```{r echo=TRUE, message=FALSE, warning=FALSE}
str(train)
```
### (A)uthor and (O)ur comments

* vendor_id only takes the values 1 or 2, presumably to differentiate two taxi companies (A)  
We can easily check this doing: (O)
```{r echo=TRUE, message=FALSE, warning=FALSE}
levels(as.factor(train$vendor_id))
```
* pickup_datetime and (in the training set) dropoff_datetime are combinations of date and time that we will have to re-format into a more useful shape (A)
* passenger_count takes a median of 1 and a maximum of 9 in both data sets (A)
* The pickup/dropoff_longitute/latitute describes the geographical coordinates where the meter was activate/deactivated (A)
* store_and_fwd_flag is a flag that indicates whether the trip data was sent immediately to the vendor ("N") or held in the memory of the taxi because there was no connection to the server ("Y"). Maybe there could be a correlation with certain geographical areas with bad reception? (A)
* trip_duration: our target feature in the training data is measured in seconds.  

## 1.4 Missing values  
To avoid an inappropriate analysis of the data, the missing values should be analysed to measure their impact in the whole dataset.  
If the number of cases is __less than 5%__ of the sample, then the researcher __can drop them.__  
For more info about this subject: https://www.statisticssolutions.com/missing-values-in-data/  
Luckly there is no missing values in data (easy mode):  
```{r echo=TRUE, message=FALSE, warning=FALSE}
sum(is.na(train))
sum(is.na(test))
```
## 1.5 Combining train and test  
Here the author did an interesting move: he combined _train_ and _test_ data sets into a single one in order to avoid a closely approach that matches just one part of data.  
__CAUTION:__ we can only combine the two data sets for a better overview but for the creation of a machine learning model we should keep _train_ and _test_ separate.  
```{r echo=TRUE, message=FALSE, warning=FALSE}
# Mutate creates dset, dropff_datetime and trip_duration columns for test dataset
# For train dataset only dset is created by mutate
# bind_rows combines the data sets into one
combine <- bind_rows(train %>% mutate(dset = "train"), 
                     test %>% mutate(dset = "test",
                                     dropoff_datetime = NA,
                                     trip_duration = NA))
combine <- combine %>% mutate(dset = factor(dset))
glimpse(combine)
```
## 1.6 Reformating features
For our following analysis, we will turn the data and time from characters into date objects. We also recode vendor_id as a factor. This makes it easier to visualise relationships that involve these features.  
```{r echo=TRUE, message=FALSE, warning=FALSE}
library('lubridate')
train <- train %>%
  mutate(pickup_datetime = ymd_hms(pickup_datetime),
         dropoff_datetime = ymd_hms(dropoff_datetime),
         vendor_id = factor(vendor_id),
         passenger_count = factor(passenger_count))
```
## 1.7 Consistency check
__ASSUME NOTHING!__ It is worth checking whether the trip_durations are consistent with the intervals between the pickup_datetime and dropoff_datetime. Presumably the former were directly computed from the latter, but you never know. Below, the check variable shows "TRUE" if the two intervals are not consistent:   
```{r echo=TRUE, message=FALSE, warning=FALSE}
train %>%
  mutate(check = abs(int_length(interval(dropoff_datetime,pickup_datetime)) + trip_duration) > 0) %>%
  select(check, pickup_datetime, dropoff_datetime, trip_duration) %>%
  group_by(check) %>%
  count()
```
And we find that everything fits perfectly.  
# 2. Individual feature visualisations  

```{r echo=TRUE, message=FALSE, warning=FALSE}
library(leaflet)
library(leaflet.extras)
set.seed(1234)
foo <- sample_n(train, 8e3)

leaflet(data = foo) %>% addProviderTiles("Esri.NatGeoWorldMap") %>%
  addCircleMarkers(~pickup_longitude, ~pickup_latitude, radius = 1,
                   color = "blue", fillOpacity = 0.3)
```