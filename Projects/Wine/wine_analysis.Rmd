---
title: "Statistics - Wine"
author: "IA - 04"
date: "1 de janeiro de 2019"
output:
  html_document:
    fig_height: 6
    fig_width: 10
    number_sections: yes
    toc: yes
    code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Parte I

## Bibliotecas
```{r echo=TRUE, warning=FALSE, message=FALSE}
library(data.table)
library(dplyr)
library(ggplot2)
library(grid)
library(plotly)
library(tibble)
library(stringr)
library(rpart)
library(rpart.plot)
```

## Importando os dados
```{r echo=TRUE, warning=FALSE, message=FALSE}
wine_dset <- read.csv2('BaseWine_Red_e_White2018.csv')
```

### Identificando as variáveis

Para começar nossa análise vamos identificar as variáveis para entender o que elas podem significar no contexto da composição de um vinho. 

```{r var_vinhos}
str(wine_dset)
```
<BR>
"fixedacidity" -> *Acidex Fixa* : Acidez é uma das características básica que tem uma contribuição  relevante para o sabor, frescura, equilíbrio e capacidade de conservação dos vinhos. Acidez Fixa é a diferença entre acidez total do vinho e sua acidez volátil. <BR><BR>

"volatileacidity" -> *Acidex Volátil* : É um componente do vinho que tipicamente cresce conforme o vinho envelhece e, em quando atinge um nível elevado, é responsável pelo aroma de vinagre. É o resultado da falta de cuidados durante a vinificação. <BR><BR>

"citricacid" -> *Ácido Cítrico* : Nos vinhos o ácido cítrico tem pouca ou nenhuma presença. Nos vinhos tintos desaparece devido à ação de bactérias láticas (fermentação malolática). Sensorialmente é fresco, porém em alguns casos pode apresentar um leve final amargo. <BR><BR>

"residualsugar" -> *Açucar Residual* : No processo de fermentação do vinho a levedura vai transformando o açúcar da uva em álcool. Por isso que, em teoria, quanto mais açúcar houver na uva, mais álcool haverá no vinho. Porem nem todo o açucar é transformado em alcool, e o açucar que resta no final do processo de fermentação é conhecido como açucar residual. <BR><BR>

"chlorides" -> *Cloretos* : Os vinhos possuem em sua composição diversos produtos enológicos, sais e ácidos. Estes sais influenciam diretamente em sua qualidade. <BR><BR>

"freesulfurdioxide" -> *Dioxido de Enxofre Livre* : As atividade antioxidásica do Dioxido de Enxofre bloqueia a ação de enzimas oxidantes, principalmente no início do processo de elaboração, evitando reações de oxidação e o conseqüente escurecimento do vinho. <BR><BR>

"totalsulfurdioxide" -> *Dioxido de Enxofre Total* : Dioxido de Enxofre é usado como conservante nos vinhos . <BR><BR>

"density" -> *Densidade* : Define a leveza do vinhos, e pode ser caracterizado pelo tipo da uva ou por técnicas usadas na vinificação que podem ser determinantes na concentração da bebida. <BR><BR>

"pH" -> *PH* : Vinhos são naturalmente ácidos, com a maioria indo de 2,8 a 4,0. Os níveis de pH estão intrinsecamente ligados ao estilo e qualidade dos vinhos. O pH relativamente baixo, na faixa de 3,1 a 3,4, parece ser pré-requisito para a produção de vinhos de alta qualidade com solidez. <BR><BR>

"sulphates" -> *Sulfatos* : Os sulfitos também tem um papel de conservantes nos vinhos e ajudam na extração dos compostos fenólicos do vinho, responsáveis pela concentração de cor e taninos. <BR><BR>

"alcohol" -> *Alchool* : O teor ácido é aquele responsável por conferir a textura e sensação de frescor. O teor ácido do vinho está diretamente ligado ao tipo de uva com o qual foi produzido, e o ideal é encontrar o equilíbrio perfeito entre o açúcar e a acidez ideal na hora da colheita. <BR><BR>

"quality" -> *Qualidade* : Uma infidade de aspectos influenciam na qualidade dos vinhos, desde aspectos como o nivel de oxidação, até a contaminação da rolha. <BR><BR>

"Vinho" -> *Vinho* : Os principais tipos de vinhos são Tintos e Brancos, mas há também outros tipos como vinhos roses, doces e espumantes. <BR><BR>
  
### Uma visão rápida no dataset
```{r echo=TRUE, warning=FALSE, message=FALSE}
glimpse(wine_dset)
```
  
### Tamanho do dataset dividido pelo tipo de vinho
```{r echo=TRUE, warning=FALSE, message=FALSE}
wine_dset %>% 
  group_by(Vinho) %>% 
  count()
```
  
### Integridade dos dados por tipo de vinho
```{r echo=TRUE, warning=FALSE, message=FALSE}
wine_white_dset <- 
  wine_dset %>%
  filter(Vinho == 'WHITE')

wine_red_dset <- 
  wine_dset %>% 
  filter(Vinho == 'RED')

sum(is.na(wine_white_dset))
sum(is.na(wine_red_dset))
                      
```
  
  
### Característica de cada tipo de vinho  
O vinho branco e vermelho apresentam características diferentes que definem se ele é bom ou ruim. Vamos dar uma olhada nos dados pra cada característica:  
  
#### Sumário dos dados  
  
  
__Vinho Branco__  
```{r echo=TRUE, warning=FALSE, message=FALSE}
summary(wine_white_dset)
```
  
  
__Vinho Vermelho__  
```{r echo=TRUE, warning=FALSE, message=FALSE}
summary(wine_red_dset)
```
  
##### Diferença da mediana das características  
  
  
__Medianas - Tinto dataset__

```{r echo=TRUE, warning=FALSE, message=FALSE}
## fixedacidity

median_red_dset <-  sapply(select(wine_red_dset, -c(Vinho, id_vinho, quality)), median)


median_red_dset <- as.data.frame(median_red_dset)
`colnames<-`(median_red_dset, "Median")

```
  
  
__Medianas - Branco dataset__
```{r echo=TRUE, warning=FALSE, message=FALSE}


median_white_dset <-  sapply(select(wine_white_dset, -c(Vinho, id_vinho, quality)),median)

median_white_dset <- as.data.frame(median_white_dset)
`colnames<-`(median_white_dset, "Median")

```
  
  
__Diferença das medianas entre os dois tipos de vinhos__
```{r echo=TRUE, warning=FALSE, message=FALSE}

Cmedian_differenc <- abs(median_white_dset - median_red_dset)
Cmedian_differenc <- `colnames<-`(Cmedian_differenc, "Mediana_Difer")
Cmedian_differenc <- rownames_to_column(Cmedian_differenc)
Cmedian_differenc %>%
  arrange(desc(Mediana_Difer)) %>%
  rename(Caracteristica = rowname)
```

Nota: a ordem descendente dessas características será utilizada nos plots para uma melhor visualização: 

##### Histogramas de cada característica  
```{r echo=TRUE, warning=FALSE, message=FALSE}
plot_ly(wine_dset, y = ~totalsulfurdioxide,type = "box",
              color = ~Vinho, colors = c("red", "khaki")) %>% 
      layout(title = "Dióxido de Enxofre Total")

```
  
```{r echo=TRUE, warning=FALSE, message=FALSE}

plot_ly(wine_dset, y = ~freesulfurdioxide,type = "box",
              color = ~Vinho, colors = c("red", "khaki")) %>% 
      layout(title = "Dióxido de Enxofre Livre")

```
  
```{r echo=TRUE, warning=FALSE, message=FALSE}

plot_ly(wine_dset, y = ~residualsugar,type = "box",
              color = ~Vinho, colors = c("red", "khaki")) %>% 
      layout(title = "Açúcar Residual")

```
  
```{r echo=TRUE, warning=FALSE, message=FALSE}

plot_ly(wine_dset, y = ~fixedacidity,type = "box",
              color = ~Vinho, colors = c("red", "khaki")) %>% 
      layout(title = "Acidez Fixa")

```

Notando a media de cada característica, vemos uma diferença considerável pra cada vinho (Branco ou Vermelho), portanto, vamos pegar somente um tipo de vinho para uma análise coerente.  
  
Como o número de dados pros vinhos brancos é bem maior do que o para os vermelhos (aprox. 3 vezes maior), seria interessante utilizar os dados que oferecem mais amostras pra treinar e validar nosso modelo.  

# Parte II - (Vinhos Brancos)

A partir da análise acima, decidimos continuar somente com os vinhos branco por causa da quantidade e outros aspectos relevantes das váriaveis envolvidas.

## Regresão Linear

Indentificando os componentes principais do dataset

```{r echo=TRUE, warning=FALSE, message=FALSE}

#install.packages("dplyr")
library(dplyr)

vinhos_brancos <- wine_dset %>% filter(Vinho == 'WHITE')

vinhos_brancos <- vinhos_brancos[2:13]

fix(vinhos_brancos)

Padr_Vinhos <- scale(vinhos_brancos)
acpcor <- prcomp(Padr_Vinhos, scale = TRUE)

summary(acpcor)

plot(1:ncol(Padr_Vinhos), acpcor$sdev^2, type = "b", xlab = "Componente",
     ylab = "Variância", pch = 20, cex.axis = 0.8, cex.lab = 0.8)

```

Como podemos observar os componentes PC1, PC2, PC3 e PC4 se mostram os mais relevantes para a escolha do modelo.

```{r echo=TRUE, warning=FALSE, message=FALSE}

Vinhos2 <- vinhos_brancos %>%
  mutate(pc1 = acpcor$x[, 1]) %>%
  mutate(pc2 = acpcor$x[, 2]) %>%
  mutate(pc3 = acpcor$x[, 3]) %>%
  mutate(pc4 = acpcor$x[, 4]) 

matcor <- cor(Vinhos2)

#install.packages("corrplot")
library(corrplot)

corrplot::corrplot(matcor, method="circle", order="hclust")

```

Com base no gráfico gerado de componentes principais;

Podemos observar que cada componente gerado pelo componentes principais
tem uma certa especialidade. 

A correlação de PC1 com alcohol,residualsugar,totalsulfurdioxide e density são maiores em relação as outras variáveis.

A correlação de PC2 com Ph, fixadacity são maiores em relação as outras variáveis.

A correlação de PC3 com citricacid, volatileacidity e fixadacity são maiores em relação as outras variáveis.

A correlação de PC4 com chlorides e sulphates são maiores em relação as outras variáveis.

Mediante nossa análise dos componentes principais desse dataset, vamos utilizar os modelos PC1 e PC3, por possuirem melhor
correlação com a variável qualidade: 


### Analisando o modelo

Variáveis dependentes: 
ModeloPC1 <- (quality)
ModeloPC3 <- (quality)

Variáveis independentes:
ModeloPC1 <- (alchool,residualsugar,totalsulfurdioxide,density)
ModeloPC3 <- (citricacid,volatileacidity,fixedacidity)

#### Analisando os coefficientes

Analisando os coefficientes

```{r echo=TRUE, warning=FALSE, message=FALSE}

attach(vinhos_brancos)

modelopc1 <- summary(lm(quality ~ alcohol+residualsugar+totalsulfurdioxide+density))
modelopc1

modelopc3 <- summary(lm(quality ~ citricacid+volatileacidity+fixedacidity))
modelopc3

```

Podemos observar no ModeloPC1;

quality <- 100.7 + 0.2366(alcohol) + 0.05542(residualsugar) + 0.0004428(totalsulfurdioxide) + 98.35(density)

R² <- 21,06%

Verificamos então que esse modelopc1 como tentativa de escolher um modelo que explique a variável quality, percebemos estatisticamente que os estimadores para o caso de beta 3 (totalsulfurdioxide) é muito próximo de 0. Assumindo um nível de significância a 5% de probabilidade podemos vê que o P valor de beta 3 (totalsulfurdioxide), é superior ao nível de significância.

Por esses motivos apresentados não a porque colocar totalsulfurdioxide no modelo.

Podemos observar no ModeloPC3;

Verificamos então que esse modelopc3 como tentativa de escolher um modelo que explique a variável quality, percebemos
estatisticamente que os estimadores para o caso de beta 1 (citricacid) é muito próximo de 0. Pelo mesmo motivo apresentado do modelopc1. Não a porque colocar citricacid no modelo.

quality <- 7.21420 - 0.28680(citricacid) - 1.76242(volatileacidity) - 0.12247(fixedacidity)

R² <- 51,89%

Reavaliando Modelos, depois da análise.

```{r echo=TRUE, warning=FALSE, message=FALSE}

modelopc1 <- summary(lm(quality ~ alcohol+residualsugar+density))
modelopc1

modelopc3 <- summary(lm(quality ~ volatileacidity+fixedacidity))
modelopc3

```

Podemos perceber agora que R² do modelopc1 é 21,02% e R² do modelopc3 é 51,87%. Por esse motivo escolhemos o modelopc3. Mesmo R² do modelopc3 não sendo muito adequado, foi o melhor que conseguimos, realizando diversos testes.

#### Verificar pressuposições

##### Residuos

```{r echo=TRUE, warning=FALSE, message=FALSE}

res <- rstandard(lm(quality ~ volatileacidity+fixedacidity))

modelo_fim <- lm(quality ~ volatileacidity+fixedacidity)

plot(predict(modelo_fim), res, xlab = "Preditor linear",ylab = "Residuos")
abline(h = 0, lty = 2)


qqnorm(residuals(modelo_fim), ylab="Residuos",xlab="Quantis teóricos",main="")
qqline(residuals(modelo_fim))
```

##### Teste de normalidade(Shapiro-Wilk)

```{r echo=TRUE, warning=FALSE, message=FALSE}

shapiro.test(res)

```

Verificando os residuos do modelo escolhido, nos mostra que pelo teste de normalidade utilizando a estatística do teste e obtendo o resultado de 0.97168 e o p valor de 2.2e-16. O valor de P do teste é pequeno por isso rejeita-se a hipótese de
normalidade dos residuos e por consequência, conclui-se que os erros não são normalmente distribuídos

## Árvore de regressão

Variáveis dependentes: 
ModeloPC1 <- (quality)
ModeloPC3 <- (quality)

Variáveis independentes:
ModeloPC1 <- (alcohol+residualsugar+density)
ModeloPC3 <- (volatileacidity+fixedacidity)

### Analisando Modelos

Modelo PC1

```{r echo=TRUE, warning=FALSE, message=FALSE}


modelopc1 <- rpart (quality ~ alcohol+residualsugar+density, data=vinhos_brancos, 
                     cp = 0.001,minsplit = 2,maxdepth=5)

summary(modelopc1)

rpart.plot(modelopc1, type=2, extra="auto", under=FALSE, clip.right.labs=TRUE,
           fallen.leaves=TRUE,   digits=2, varlen=-3, faclen=15,
           cex=NULL, tweak=1.7,
           compress=TRUE,box.palette="auto",
           snip=FALSE)

Val_pred_tree <- predict(modelopc1,interval = "prediction", level = 0.95) 
str(Val_pred_tree)


mse_tree <- mean((quality - Val_pred_tree)^2)
sqrt(mse_tree)



```

Podemos observar no ModeloPC1;

Porcetangem de importância das variáveis escolhidas

alcohol <- 53%
density <- 34%
residualsugar <-13% 

Número de Node criados 63 
Número de observações 4898

Maiores médias, levando em conta a taxa de cada variável

mean = 6.555556 | 
residualsugar < 1.75 | 
density < 0.990005 | 
alcohol < 13.65 

mean = 6.763948 |
residualsugar < 2.15 |
density < 0.98987 |
alcohol < 12.89667

mean = 6.875 |
alcohol < 13.55 |
residualsugar < 2.25 |
density < 0.98953


Percebemos que os vinhos com valor de residualsugar abaixo de 2.5 tem um potencial de qualidade maior, como também os vinhos com valor de density abaixo de 1 e alcohol abaixo de 14 também contribuem para um vinho de maior qualidade. Com tudo um pode equilibrar o outro na dosagem certa.


Modelo PC3

```{r echo=TRUE, warning=FALSE, message=FALSE}


modelopc3 <- rpart (quality ~ volatileacidity+fixedacidity, data=vinhos_brancos, 
                     cp = 0.001,minsplit = 2,maxdepth=5)

summary(modelopc3)

rpart.plot(modelopc3, type=2, extra="auto", under=FALSE, clip.right.labs=TRUE,
           fallen.leaves=TRUE,   digits=2, varlen=-3, faclen=15,
           cex=NULL, tweak=1.7,
           compress=TRUE,box.palette="auto",
           snip=FALSE)

Val_pred_tree2 <- predict(modelopc3,interval = "prediction", level = 0.95) 
str(Val_pred_tree)

mse_tree <- mean((quality - Val_pred_tree2)^2)
sqrt(mse_tree)

```

Podemos observar no ModeloPC3;

Porcetangem de importância das variáveis escolhidas

volatileacidity <- 59%
fixedacidity <- 41%

Número de Node criados 63 
Número de observações 4898

Maiores médias, levando em conta a taxa de cada variável

mean = 6.135546 |
volatileacidity < 0.195 |
fixedacidity    < 6.175

mean = 6.213192 |
fixedacidity < 7.45 |
volatileacidity < 0.1325

mean = 6.294643 |
volatileacidity < 0.525 |
fixedacidity < 5.35

Percebemos que os vinhos com valor de volatileacidity abaixo de 0.1300 tem um potencial de qualidade maior, como também os vinhos com valor de fixedacidity abaixo de 7.45 também contribuem para um vinho de maior qualidade. Com tudo um pode equilibrar o outro na dosagem certa.

## Resumo Regressão linear / Árvore de Regressão

Com base nas duas técnicas conseguimos enxergam alguns componentes que elevaram o padrão de qualidade do vinho, com alguns diferenciais para cada uma. A técnica de regressão linear parece ser mais segura em mostrar que os componentes citricacid, volatileaciditye e fixedacidity são os causadores de uma maior qualidade do vinho. Já a técnica de árvore de regressão mostra de uma forma mais transparente e fácil de enxergar que a qualidade do vinho é mais elevada por causa dos componentes residualsugar, density e alcohol. Ou seja o modelo pc3 se mostrou mais adequado na regressão linear, e o modelo pc1 se mostrou mais adequado na árvore de regressão.

No contexto geral o modelo PC1 mostrou os melhores resultados, usando a Árvore de Regressão.


