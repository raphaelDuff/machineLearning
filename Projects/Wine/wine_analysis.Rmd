---
title: "Statistics - Wine"
author: "Raphael Prates"
date: "13 de dezembro de 2018"
output:
  html_document:
    fig_height: 6
    fig_width: 10
    number_sections: yes
    toc: yes
    code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Bibliotecas
```{r echo=TRUE, warning=FALSE, message=FALSE}
library(data.table)
library(dplyr)
library(ggplot2)
library(grid)
library(plotly)
library(tibble)
library(stringr)
```

# Importando os dados
```{r echo=TRUE, warning=FALSE, message=FALSE}
wine_dset <- read.csv2('BaseWine_Red_e_White2018.csv')
```
  
## Uma visão rápida no dataset
```{r echo=TRUE, warning=FALSE, message=FALSE}
glimpse(wine_dset)
```
  
## Tamanho do dataset dividido pelo tipo de vinho
```{r echo=TRUE, warning=FALSE, message=FALSE}
wine_dset %>% 
  group_by(Vinho) %>% 
  count()
```
  
## Integridade dos dados por tipo de vinho
```{r echo=TRUE, warning=FALSE, message=FALSE}
wine_white_dset <- 
  wine_dset %>%
  filter(Vinho == 'WHITE')

wine_red_dset <- 
  wine_dset %>% 
  filter(Vinho == 'RED')

sum(is.na(wine_white_dset))
sum(is.na(wine_red_dset))
                      
```
  
O vinho branco e vermelho apresentam características diferentes que definem se ele é bom ou ruim. Vamos dar uma olhada nos dados pra cada característica:  
  
## Característica de cada tipo de vinho  
  
### Sumário dos dados  
  
  
__Vinho Branco__  
```{r echo=TRUE, warning=FALSE, message=FALSE}
summary(wine_white_dset)
```
  
  
__Vinho Vermelho__  
```{r echo=TRUE, warning=FALSE, message=FALSE}
summary(wine_red_dset)
```
  
#### Diferença da mediana das características  
  
  
__Medianas - Tinto dataset__

```{r echo=TRUE, warning=FALSE, message=FALSE}
## fixedacidity

# wine_dset %>% 
#   ggplot(aes(fixedacidity, fill = Vinho)) +
#   geom_boxplot()

# wine_Cmedian

# ou
# > sapply(teste_matrix, median)

# ou 
# > sort(teste_matrix$ColunaB)

median_red_dset <-  sapply(select(wine_red_dset, -c(Vinho, id_vinho, quality)), median)


median_red_dset <- as.data.frame(median_red_dset)
`colnames<-`(median_red_dset, "Median")

```
  
  
__Medianas - Branco dataset__
```{r echo=TRUE, warning=FALSE, message=FALSE}


median_white_dset <-  sapply(select(wine_white_dset, -c(Vinho, id_vinho, quality)),median)

median_white_dset <- as.data.frame(median_white_dset)
`colnames<-`(median_white_dset, "Median")

```
  
  
__Diferença das medianas entre os dois tipos de vinhos__
```{r echo=TRUE, warning=FALSE, message=FALSE}

Cmedian_differenc <- abs(median_white_dset - median_red_dset)
Cmedian_differenc <- `colnames<-`(Cmedian_differenc, "Mediana_Difer")
Cmedian_differenc <- rownames_to_column(Cmedian_differenc)
Cmedian_differenc %>%
  arrange(desc(Mediana_Difer)) %>%
  rename(Caracteristica = rowname)
```

Nota: a ordem descendente dessas características será utilizada nos plots para uma melhor visualização: 

#### Histogramas de cada característica  
  
  
__Multiplot function__  
```{r echo=TRUE, warning=FALSE, message=FALSE}

# Define multiple plot function
#
# ggplot objects can be passed in ..., or to plotlist (as a list of ggplot objects)
# - cols:   Number of columns in layout
# - layout: A matrix specifying the layout. If present, 'cols' is ignored.
#
# If the layout is something like matrix(c(1,2,3,3), nrow=2, byrow=TRUE),
# then plot 1 will go in the upper left, 2 will go in the upper right, and
# 3 will go all the way across the bottom.
#

multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {

  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)

  numPlots = length(plots)

  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                    ncol = cols, nrow = ceiling(numPlots/cols))
  }

 if (numPlots==1) {
    print(plots[[1]])
  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))

    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))

      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}

```
  
```{r echo=TRUE, warning=FALSE, message=FALSE}

plot_ly(wine_dset, y = ~totalsulfurdioxide,type = "box",
              color = ~Vinho, colors = c("red", "khaki")) %>% 
      layout(title = "Total sulfurdioxide")

```
  
```{r echo=TRUE, warning=FALSE, message=FALSE}

plot_ly(wine_dset, y = ~freesulfurdioxide,type = "box",
              color = ~Vinho, colors = c("red", "khaki")) %>% 
      layout(title = "Total sulfurdioxide")

```
  
```{r echo=TRUE, warning=FALSE, message=FALSE}

plot_ly(wine_dset, y = ~residualsugar,type = "box",
              color = ~Vinho, colors = c("red", "khaki")) %>% 
      layout(title = "Total sulfurdioxide")

```
  

```{r echo=TRUE, warning=FALSE, message=FALSE}

plot_ly(wine_dset, y = ~fixedacidity,type = "box",
              color = ~Vinho, colors = c("red", "khaki")) %>% 
      layout(title = "Total sulfurdioxide")

```

Notando a media de cada característica, vemos uma diferença considerável pra cada vinho (Branco ou Vermelho), portanto, vamos pegar somente um tipo de vinho para uma análise coerente.  
  
Como o número de dados pros vinhos brancos é bem maior do que o para os vermelhos (aprox. 3 vezes maior), seria interessante utilizar os dados que oferecem mais amostras pra treinar e validar nosso modelo.  
  
